<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UNet++ Segmentation Demo</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    #upload-box {
      border: 2px dashed #888;
      padding: 40px;
      text-align: center;
      color: #666;
      margin-bottom: 20px;
      cursor: pointer;
    }
    #upload-box.hover {
      border-color: #444;
      color: #444;
    }
    #canvasContainer {
      position: relative;
      display: inline-block;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #controls {
      margin-bottom: 10px;
    }
    #controls label, #controls select {
      margin-right: 10px;
    }
  </style>
</head>
<body>

  <h2>UNet++ Segmentation Demo</h2>

  <div id="upload-box">
    Drag and drop or click to upload image<br>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
  </div>

  <div id="controls" style="display:none">
    <label for="categorySelect">Select category:</label>
    <select id="categorySelect"></select>
  </div>

  <div id="canvasContainer" style="display:none">
    <canvas id="imageCanvas"></canvas>
    <canvas id="maskCanvas"></canvas>
  </div>

  <script>
    // VOC 2012 class mapping
    const VOC_CLASSES = [
      'background','aeroplane','bicycle','bird','boat',
      'bottle','bus','car','cat','chair',
      'cow','diningtable','dog','horse','motorbike',
      'person','pottedplant','sheep','sofa','train','tvmonitor'
    ];

    const uploadBox = document.getElementById('upload-box');
    const fileInput = document.getElementById('fileInput');
    const categorySelect = document.getElementById('categorySelect');
    const controls = document.getElementById('controls');
    const canvasContainer = document.getElementById('canvasContainer');
    const imageCanvas = document.getElementById('imageCanvas');
    const maskCanvas = document.getElementById('maskCanvas');

    let maskData = null;
    let imgWidth = 0, imgHeight = 0;

    // Fill category dropdown
    VOC_CLASSES.forEach((name, idx) => {
      const opt = document.createElement('option');
      opt.value = idx;
      opt.text = `${idx}: ${name}`;
      categorySelect.appendChild(opt);
    });

    // Event binding
    uploadBox.addEventListener('click', () => fileInput.click());
    uploadBox.addEventListener('dragover', e => {
      e.preventDefault();
      uploadBox.classList.add('hover');
    });
    uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('hover'));
    uploadBox.addEventListener('drop', e => {
      e.preventDefault();
      uploadBox.classList.remove('hover');
      handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', () => handleFile(fileInput.files[0]));
    categorySelect.addEventListener('change', () => {
      if (maskData) drawMask();
    });

    function handleFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        const img = new Image();
        img.onload = () => processImage(img);
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    }

    function processImage(img) {
      imgWidth  = img.width;
      imgHeight = img.height;
      [imageCanvas, maskCanvas].forEach(cv => {
        cv.width  = imgWidth;
        cv.height = imgHeight;
      });
      // Draw original image
      const ctx = imageCanvas.getContext('2d');
      ctx.clearRect(0, 0, imgWidth, imgHeight);
      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);

      // Show controls
      controls.style.display = 'block';
      canvasContainer.style.display = 'inline-block';

      // Send to backend
      sendToBackend();
    }

    function sendToBackend() {
      imageCanvas.toBlob(blob => {
        const form = new FormData();
        form.append('file', blob, 'input.png');
        fetch('http://127.0.0.1:8000/predict', { method: 'POST', body: form })
          .then(res => res.json())
          .then(json => {
            maskData = json.mask;  // Expect mask: [w*h] flat array
            // Validate if mask data is empty or contains only one category
            const uniqueValues = new Set(maskData);
            console.log("Unique values in mask:", Array.from(uniqueValues));
            drawMask();
          })
          .catch(err => {
            console.error('Prediction failed', err);
            alert('Model inference failed, please check the backend /predict endpoint');
          });
      });
    }

    function drawMask() {
      const categoryId = parseInt(categorySelect.value);
      const ctx = maskCanvas.getContext('2d');
      const imgData = ctx.createImageData(imgWidth, imgHeight);
      for (let i = 0, len = maskData.length; i < len; i++) {
        const lbl = maskData[i];
        const j = i * 4;
        if (lbl === categoryId) {
          imgData.data[j + 0] = 255; // R
          imgData.data[j + 1] = 0;   // G
          imgData.data[j + 2] = 0;   // B
          imgData.data[j + 3] = 128; // 0.5 alpha
        } else {
          imgData.data[j + 3] = 0;
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }
  </script>

</body>
</html>
